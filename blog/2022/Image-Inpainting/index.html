<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Image Inpainting using Deep Learning | Naga Harshita Marupaka </title> <meta name="author" content="Naga Harshita Marupaka"> <meta name="description" content="Image Inpainting using Deep Learning"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nagaharshita.github.io//blog/2022/Image-Inpainting/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Image Inpainting using Deep Learning",
            "description": "Image Inpainting using Deep Learning",
            "published": "February 20, 2022",
            "authors": [
              
              {
                "author": "Naga Harshita Marupaka",
                "authorURL": "https://www.linkedin.com/in/nagaharshitamarupaka/",
                "affiliations": [
                  {
                    "name": "IIITS",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Abhinay Bathina",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "IIITS",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Hemanth Krishna Balineni",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "IIITS",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Naga Harshita</span> Marupaka </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Image Inpainting using Deep Learning</h1> <p>Image Inpainting using Deep Learning</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#problem-statement">Problem Statement</a> </div> <div> <a href="#related-works">Related works</a> </div> <div> <a href="#traditional-methods">Traditional Methods</a> </div> <div> <a href="#learning-based-techniques">Learning-based Techniques</a> </div> <div> <a href="#vision-transformers">Vision Transformers</a> </div> <div> <a href="#thesis-project">Thesis Project</a> </div> <div> <a href="#gated-convolution">Gated Convolution</a> </div> <div> <a href="#transgan">TransGAN</a> </div> <div> <a href="#transformer-vs-cnn">Transformer vs CNN</a> </div> <div> <a href="#results">Results</a> </div> </nav> </d-contents> <h2 id="problem-statement">Problem statement</h2> <p>Image Inpainting is a technique for reconstructing an image’s missing pixels or missing regions. This approach is used to either delete an object from a picture or recover the image’s corrupted elements. These are being used in the form of 3D image inpainting in medical images and AR/VR technologies in recent trends. It’s a significant solution to remove image occlusions. Object removal, picture restoration, modification, re-targeting, compositing, and image-based rendering are among the imaging and graphics applications that use it. Our main goal is to construct an efficient and robust inpainter by leveraging the most recent and proven architectures and techniques in computer vision.</p> <h2 id="related-works">Related works</h2> <p>Without deep learning, there is a whole realm of computer vision to explore. Object detection was still possible before Single Shot Detectors (SSDs) were invented (although the precision was not anywhere near what SSDs are capable of). In the same way, there are a few traditional computer vision approaches for image inpainting. Inpainting techniques can be divided into two categories: traditional and learning-based. We looked at methods from both classes in this part, as well as provided further detail on the techniques used in the comparison.</p> <h3 id="traditional-methods">Traditional Methods</h3> <p>The traditional image inpainting approaches, also known as traditional or non-learning-based approaches, perform the inpainting process using specific algorithms and can be divided into two categories: diffusion-based methods and patch-based methods. Traditional methods do not necessitate any training. As a result, it’s a good technique for solving easy problems. When the masked area in the image begins to develop a proportionally huge area, traditional methods do not perform well. Given that these algorithms infer from pixels near the missing region, this result is expected.</p> <p><strong>Patch-Based Methods</strong></p> <p>In patch-based image inpainting, the undamaged regions of the image are used to build the region to be filled. The goal of this method is to achieve the maximum possible patch similarity level. While patch-based approaches are effective, they assume that the information in the missing portion of the image is stored somewhere else in the image. Patch-based approaches require more processing power because they are methods that involve searching and comparing all of the time.</p> <ol> <li>Patch-based Texture Synthesis</li> <li>Image Melding</li> </ol> <p><strong>Diffusion based method</strong></p> <p>The first type of digital image inpainting technique was diffusion-based inpainting. The diffusion process covers the image. This inpainting method was developed by integrating principles from classical fluid dynamics with partial equations, and it is still one of the most often used traditional methods today. The assumption is that the image’s edges are continuous.</p> <ol> <li>Navier-Stokes Method</li> <li>Fast Marching Method</li> </ol> <h3 id="learning-based-techniques">Learning-based Techniques</h3> <p>Deep learning algorithms have been used for image inpainting, as they have been for many other computer vision challenges. Deep learning approaches are becoming more popular as time goes on because, when compared to older methods, they produce better results in complex problems. The fundamental reason for this is the generation of large-scale datasets that will allow deep methods to be trained, as well as the processing capacity that will allow these deep methods to be trained.</p> <p><strong>CNN-based Methods</strong></p> <p>Convolutional neural network structures, which are well-known for their grid-like layer topology and high success in computer vision studies, are also used in image inpainting research and produce excellent results. Many architectures are designed specifically for inpainting work. The architecture of the U-Net One of these is the U-Net architecture, which was used in the Shift-Net inpainting study. This architecture uses convolutional layers to combine an image and a mask that shows where the missing portions are. In a symmetrical design, it concatenates each layer’s output with the output of the corresponding layer of the same size 24. In terms of generated picture structure and fine detail, the outcomes of this structure are really successful.</p> <p><strong>GAN-based Methods</strong></p> <p>Various deep learning methods have been tested over time, and it has been determined that some methods produce better results. CNN and GAN-based algorithms, it may be stated, are superior at analyzing realistic results in images. Methods are based on the GAN concept.</p> <p>An encoder-decoder design first creates a feature space using its encoder, according to the research Context Encoder: Feature Learning by Inpainting. The decoder then uses that area to generate a realistic inpainted output image. Furthermore, by integrating two losses, vastly better and more realistic results can be obtained.</p> <p>In addition to this research, many techniques for resolving various difficulties have been offered. Using fewer downsampling layers is recommended to avoid blurry regions in the produced images. Furthermore, instead of fully connected layers, dilated convolution layers were used. Unfortunately, because of the relatively sparse filters created by the dilation element, these adjustments resulted in longer training times. SC-FEGAN used gated and dilated gated convolutional layers in an image completion study.</p> <p><strong>Edge Connect</strong></p> <p>The model’s working logic is divided into four phases. In a nutshell, each iteration’s input image is directed to the dataset script. The method of detecting an edge and extracting the image from the colour channels is conducted in this dataset script. The edge and grey image are given to the edge model as input from the parts obtained in this stage. The output is reverse masked before even being added to the original portions. As a result, we only get the part of the output picture that is produced around the masked region. The RGB image is then given to the inpainted model and reversely masked to use the edge information obtained from this section.</p> <h3 id="vision-transformers">Vision Transformers</h3> <p>When compared to convolutional neural networks (CNN), Vision Transformer (ViT) achieves remarkable results while using less computational resources for pre-training. When training on smaller datasets, Vision Transformer (ViT) does have a weaker inductive bias than convolutional neural networks (CNN), resulting in a greater reliance on model regularisation or data augmentation (AugReg).</p> <p>The ViT is a visual model based on a transformer’s architecture, which was originally designed for text-based activities. The ViT model represents an input image as a series of image patches, similar to how word embeddings are represented in text when utilizing transformers, and predicts class labels for the image directly. When trained on enough data, ViT outperforms an equivalent state-of-the-art CNN using 4x fewer Computational resources.</p> <p>The optimizer’s decision, network depth, and dataset-specific hyperparameters all affect the performance of a vision transformer model. CNN’s are less difficult to improve than ViT. The difference between a pure transformer and a CNN front end is to marry a transformer to a CNN front end. A 16*16 convolution with a 16 stride is used in the conventional ViT stem. A 3*3 convolution with stride 2 on the other hand, improves stability and precision.</p> <p>In machine learning, a transformer is a deep learning model that uses attention mechanisms to weigh the significance of each part of the input data differently. Machine learning transformers are made up of many self-attention layers. Natural language processing (NLP) and computer vision are two AI subfields that employ them extensively (CV).</p> <h2 id="thesis-project">Thesis Project</h2> <p>We have chosen a paper to work on [6]. We trained our model using the techniques Gated convolution and SN patch-based GAN. Our team with our mentor has agreed to work on the paper “Free-form image inpainting using gated convolution”.</p> <h2 id="gated-convolution">Gated Convolution</h2> <h4 id="dataset-and-preprocessing">Dataset and Preprocessing</h4> <p><strong>Used Dataset: Places2</strong></p> <p>Link for Places2 dataset: <a href="http://places2.csail.mit.edu/" rel="external nofollow noopener" target="_blank">http://places2.csail.mit.edu/</a></p> <p>We evaluated the image inpainting system by using the Places2 dataset in which it has many images and these images are of wide ranges of varieties. Here we have taken a set of 15k images in the ratio of 70:30 for the training of the model and for testing of the model. Here the selected images are of different features which are vast in numbers. In the future, we will train faces for the CelebA-HQ dataset.</p> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/1-480.webp 480w,/assets/img/image-inpainting/1-800.webp 800w,/assets/img/image-inpainting/1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Images present in Places2 Dataset </div> <p>The above figure1 depicts some of the images present in the Places2 dataset.</p> <p>This dataset has undergone transformations mainly random cropping, horizontal flip, and vertical flip.</p> <p>Flists are the list of paths of the images from the datasets which are shuffled. These Flists are used to open the images during training and convert them into different resolutions for easy training.</p> <p>During the training process, we have generated 100 free-form masks using an algorithm mentioned in the paper and used them for the training.</p> <h4 id="model">Model</h4> <p>The model has the Generator and Discriminator parts with the Self-attention included. The following parts of the report will explain in detail the different parts. In the Generator, we took encoder-decoder networks for obtaining the coarse image and refined image. The steps with the refined image contain Self-attention. Next, we do pass through it through the discriminator where the spectral normalization is used for attaining stability. Here the gated convolution is used instead of convolution to treat valid and invalid pixels separately.</p> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/2-480.webp 480w,/assets/img/image-inpainting/2-800.webp 800w,/assets/img/image-inpainting/2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Overview of framework with gated convolution </div> <h4 id="architecture">Architecture</h4> <p>Generative Adversarial Network(GAN) is used here to fill out the masked regions of the image. This encoder-decoder network has two parts namely Generator and Discriminator. The generator’s work is to generate the images close to the target. Discriminators’ work is to distinguish the difference between real and generated images. This Generator and Discriminator generally follow the minimax theorem in terms of losses. The GAN we used in the model is called the Spectral Normalisation Patch GAN where we used spectral normalization for ensuring stability in the Discriminator part. This is a conditional GAN where we pass both the input and the target values to attain the results. The loss functions for the Generator and the Discriminator are as follows:</p> <p><b>Generator : L<sub>G</sub> = −E <sub>z~Pz(z)</sub> [D<sup>sn</sup>(G(z))]</b></p> <p><b>Discriminator : L<sub>D</sub> = E<sub>x~Pdata(x)</sub> [ReLU( 1− D<sup>sn</sup>(x))] +E<sub>z~Pz(z)</sub> [ReLU(1 + D<sup>sn</sup>(G(z)))]</b></p> <h4 id="training-information">Training Information</h4> <p>Used 50 epochs for training our model. Used 2 lakh images as training samples and 25K as testing samples. Captured the loss functions and SSIM values.</p> <p><strong>Difficulties:</strong> It took a lot of time to train on our dataset. Google Colab frequently</p> <p>got disconnected.</p> <p><strong>GPU used:</strong> Google Colab’s Free GPU</p> <h4 id="testing-using-different-images">Testing using different images</h4> <p><strong>Rectangular mask vs Free-form mask</strong></p> <p>Taking a mask as an input we have used different kinds of masks from a set to produce outputs. Mainly here when trained we get outputs when we choose the mask as a rectangular mask and mask as a free-form mask.</p> <p><strong>Ground Truth Mask Completed Image</strong></p> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/3-480.webp 480w,/assets/img/image-inpainting/3-800.webp 800w,/assets/img/image-inpainting/3-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Input given with free-form mask </div> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/4-480.webp 480w,/assets/img/image-inpainting/4-800.webp 800w,/assets/img/image-inpainting/4-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Results of input given with free-form mask </div> <p><strong>Ground Truth Mask Completed Image</strong></p> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/5-480.webp 480w,/assets/img/image-inpainting/5-800.webp 800w,/assets/img/image-inpainting/5-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Input given with rectangular-mask </div> <p>As shown the outputs are as follows where figure 6,figure7 shows the ground truth and completed image produced by giving a free-form mask as an input.</p> <p>And figure 8 shows the ground truth and completed image produced by using a rectangular mask as an input.</p> <p><strong>About different image resolutions produced</strong></p> <p>These are the images produced when trained. Here we have got outputs in the resolutions of different sizes such as 64x64, 128x128, and 256x256 respectively.</p> <p>By looking at the results we can see that we got a clear image resolution in the 256x 256 images. Hence we will consider taking 256x256 resolution images further.</p> <div class="row justify-content-center"> <div class="col-sm-9 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/6-480.webp 480w,/assets/img/image-inpainting/6-800.webp 800w,/assets/img/image-inpainting/6-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Image produced in 64x64 size </div> <div class="row justify-content-center"> <div class="col-sm-9 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/7-480.webp 480w,/assets/img/image-inpainting/7-800.webp 800w,/assets/img/image-inpainting/7-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Image produced in 128x128 size </div> <div class="row justify-content-center"> <div class="col-sm-9 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/8-480.webp 480w,/assets/img/image-inpainting/8-800.webp 800w,/assets/img/image-inpainting/8-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Image produced in 256x256 size </div> <p>In the above pictures, Figure 9 represents 64x64 image outputs, Figure 10 represents 128x128 image outputs and Figure 11 shows 256x256 image outputs.</p> <h4 id="results">Results</h4> <p>We evaluated our model on the Places2 dataset. For testing it runs at 0.22 seconds per image on Google Colab’s GPU for images of resolution 256x256 on average, regardless of hole size. Our model has mainly 3 losses which are Generator loss [3.6], Discriminator loss[3.6], Reconstruction loss taken as L1 for original image and reconstructed image. The reconstruction loss is taken as the average for the coarse image and refined image with and without mask regions.</p> <p>By recording the SSIM values for the dataset we acquired a value of approximately 0.77 SSIM as shown in the graph figure13 below.</p> <p>Below are some of the results produced after training the model</p> <div class="row justify-content-center"> <div class="col-sm-10 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/9-480.webp 480w,/assets/img/image-inpainting/9-800.webp 800w,/assets/img/image-inpainting/9-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Result produced with the free-form mask </div> <div class="row justify-content-center"> <div class="col-sm-10 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/10-480.webp 480w,/assets/img/image-inpainting/10-800.webp 800w,/assets/img/image-inpainting/10-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Image showing multiple image outputs </div> <p>Figure 14 has the images where it has a ground truth and input is given with rectangular masks which produce respective outputs. Figure15 depicts the final image outputs produced when trained with different masks.</p> <table> <thead> <tr> <th style="text-align: left"><strong>Model</strong></th> <th style="text-align: left"><strong>Mask</strong></th> <th style="text-align: left"><strong>Dataset</strong></th> <th style="text-align: left"><strong>FID</strong></th> <th style="text-align: left"><strong>SSIM</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: left">Gated Convolution</td> <td style="text-align: left">Free-form, rectangle</td> <td style="text-align: left">Places 2</td> <td style="text-align: left">91</td> <td style="text-align: left">0.87</td> </tr> <tr> <td style="text-align: left">TransGAN</td> <td style="text-align: left">Random Rectangle</td> <td style="text-align: left">CelebA-HQ</td> <td style="text-align: left">130</td> <td style="text-align: left">0.56</td> </tr> </tbody> </table> <h4 id="limitations">Limitations</h4> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/11-480.webp 480w,/assets/img/image-inpainting/11-800.webp 800w,/assets/img/image-inpainting/11-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Results produced after training with different masks </div> <p>Our model didn’t produce great results for the images mentioned in Fig 16. In the first image with the square mask, the output was a little blur at the masked pixels. In the second image, the eyes of both persons were missing. We would like to improve the accuracy of the images obtained by refining the network and training with various masks of different colors, shapes.</p> <h4 id="conclusion">Conclusion</h4> <p>For the problem statement, we have taken i.e., Image Inpainting using Deep Learning</p> <p>techniques, we have trained a model using Spectral Normalisation Patch GAN using</p> <p>Gated convolution and Self Attention. During the training of this model, Generator loss, Discriminator loss, and Reconstruction loss are taken into account. The trained model is</p> <p>tested using different masks and different resolutions. The results obtained from testing with different types of images was satisfactory with good ssim values.</p> <h2 id="transgan">TransGAN</h2> <h4 id="dataset-and-preprocessing-1">Dataset and Preprocessing</h4> <p><strong>Used Dataset: CelebA</strong></p> <p>CelebFaces Attributes Dataset (CelebA) is a large-scale face attributes dataset with more than 200K celebrity images, each with 40 attribute annotations. The images in this dataset cover large pose variations and background clutter. Used a total of 11k images and splitted into 10k training samples and 1k testing samples.</p> <h4 id="model-1">Model</h4> <p>TransGAN is a GAN model with two Transformer architectures for the generator and discriminator. Convolutions are commonly used in GAN architecture. Convolutions are replaced by transformers in TransGAN.</p> <p>GAN is based exclusively on Transformer architectures and does not require convolutions. The following are the components of a basic TransGAN:</p> <ul> <li>A generator that improves feature resolution while simultaneously reducing the size of embeddings;</li> <li>A discriminator that only acts on specific portions of an image.</li> </ul> <div class="row justify-content-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/12-480.webp 480w,/assets/img/image-inpainting/12-800.webp 800w,/assets/img/image-inpainting/12-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Overview of framework with TransGAN </div> <h4 id="architecture-1">Architecture</h4> <p><strong>Basic Block:</strong> Similar to transformer encoder, it consists of a multi-head self-attention module and the second part is a feed-forward MLP with GELU non-linearity. It has a residual network with each layer implementing through layer normalization.</p> <p><strong>Image as input:</strong> Similar to Vision Transformers, we are dividing the image into 16 * 16 patches and encoded to the generator</p> <p><strong>Memory Friendly Generator:</strong> Similar to GANs, it consists upscaling feature to gradually increase the input sequence and reduce the embedding dimension</p> <p><strong>Patch-level Discriminator:</strong> As we need the information only it’s real or fake, the image is divided into 8 * 8 patches and passed to the transformer encoder, at last, it is flattened and a cls token is attached which confirms if it is real or fake.</p> <p><strong>Generator</strong></p> <table> <thead> <tr> <th><strong>Stage</strong></th> <th><strong>Layer</strong></th> <th><strong>Input Shape</strong></th> <th><strong>Output Shape</strong></th> </tr> </thead> <tbody> <tr> <td>-</td> <td>Image</td> <td>512</td> <td>(8 x 8) x 1024</td> </tr> <tr> <td> <br><br>1<br> </td> <td>Block<br>Block<br>Block<br>Block<br>Block<br> </td> <td>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br> </td> <td>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br>(8 x 8) x 1024<br> </td> </tr> <tr> <td> <br><br>2<br> </td> <td>PixelShuffle<br>Block<br>Block<br>Block<br>Block<br> </td> <td>(8 x 8) x 1024<br>(16 x 16) x 256<br>(16 x 16) x 256<br>(16 x 16) x 256<br>(16 x 16) x 256<br> </td> <td>(16 x 16) x 256<br>(16 x 16) x 256<br>(16 x 16) x 256<br>(16 x 16) x 256<br>(16 x 16) x 256<br> </td> </tr> <tr> <td> <br>3<br> </td> <td>PixelShuffle<br>Block<br>Block<br> </td> <td>(16 x 16) x 256<br>(32 x 32) x 64<br>(32 x 32) x 64<br> </td> <td>(32 x 32) x 64<br>(32 x 32) x 64<br>(32 x 32) x 64<br> </td> </tr> <tr> <td>-</td> <td>Linear Layer</td> <td>(32 x 32) x 64</td> <td>32 x 32 x 3</td> </tr> </tbody> </table> <p><strong>Discriminator</strong></p> <table> <thead> <tr> <th><strong>Stage</strong></th> <th><strong>Layer</strong></th> <th><strong>Input Shape</strong></th> <th><strong>Output Shape</strong></th> </tr> </thead> <tbody> <tr> <td>-</td> <td>Linear Layer</td> <td>(32 x 32) x 64</td> <td>(16 x 16) x 192</td> </tr> <tr> <td> <br><br>1<br> </td> <td>Block<br>Block<br>Block<br>AvgPooling<br>Concatenate<br> </td> <td>(16 x 16) x 192<br>(16 x 16) x 192<br>(16 x 16) x 192<br>(16 x 16) x 192<br>(8 x 8) x 192<br> </td> <td>(16 x 16) x 192<br>(16 x 16) x 192<br>(16 x 16) x 192<br>(8 x 8) x 192<br>(8 x 8) x 384<br> </td> </tr> <tr> <td> <br>2<br> </td> <td>Block<br>Block<br>Block<br> </td> <td>(8 x 8) x 384<br>(8 x 8) x 384<br>(8 x 8) x 384<br> </td> <td>(8 x 8) x 384<br>(8 x 8) x 384<br>(8 x 8) x 384<br> </td> </tr> <tr> <td> <br>-<br><br> </td> <td>Add CLS Token<br>Block<br>CLS Head<br> </td> <td>(8 x 8) x 384<br>(8 x 8 + 1) x 384<br>1 x 384<br> </td> <td>(8 x 8 + 1) x 384<br>(8 x 8 + 1) x 384<br>1<br> </td> </tr> </tbody> </table> <h4 id="training-information-1">Training Information</h4> <p>Used 130 epochs for training our model. Used 10K images as training samples and 1K images as testing samples. Captured the loss functions and SSIM values.</p> <p><strong>Difficulties:</strong> It took a lot of time to train on our dataset. It needs a lot of GPU memory to train for larger sizes.</p> <p><strong>GPU used:</strong> Kaggle’s Free GPU</p> <h4 id="results-1">Results</h4> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/13-480.webp 480w,/assets/img/image-inpainting/13-800.webp 800w,/assets/img/image-inpainting/13-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Results of input given with mask </div> <h4 id="limitations-1">Limitations</h4> <p>Our model didn’t produce great results for the images mentioned in the above image. Transformers need a lot of GPU memory to train for larger image sizes and for large datasets.</p> <h3 id="transformer-vs-cnn">Transformer vs CNN</h3> <p>When it comes to NLP models, these transformers have a high success rate, and they’re currently being used on images for image recognition tasks. ViT separates the images into visual tokens, whereas CNN uses pixel arrays. The visual transformer splits an image into fixed-size patches, embeds one each appropriately, and sends positional embedding to the transformer encoder as an input. Furthermore, ViT models beat CNNs in terms of computing efficiency and accuracy by nearly four times.</p> <p>ViT’s self-attention layer allows you to embed information globally throughout the entire image. The model also uses training data to represent the measured parallel of image patches in order to reconstruct the image’s structure.</p> <p>The transformer encoder consists of the following components:</p> <p><strong>MSP (Multi-Head Self Attention Layer):</strong> This layer concatenates all of the attention outputs to the right dimensions in a linear way. The numerous attention heads in an image assist in the training of local and global dependencies.</p> <p><strong>Layer Norm (LN):</strong> This is added before each block as there are no new dependencies between the training images. As a result, the training time and overall performance are improved.</p> <p>Furthermore, residual connections are included after each block because they allow components to pass directly through the network without having to go through non-linear activations.The MLP layer implements the classification head in the instance of image classification. At pre-training time, it uses one hidden layer and a single linear layer for fine-tuning.</p> <p><strong>3.4 Adopting transformers for Inpainting</strong></p> <p>Spectral Norm is used in the discriminator to attain stability in training. Here, a higher learning rate is used for regularised discriminator in order to solve the problem of slow learning than the Generator. L2 normalization with the power iterations [7] is applied for the images in the discriminator part.</p> <p>We used Self-attention instead of contextual attention as mentioned in the paper. We have used this in place of contextual attention for attaining better results as it captures the global knowledge of the image. This self-attention is the last step of each Generator and Discriminator.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/image-inpainting/image-480.webp 480w,/assets/img/image-inpainting/image-800.webp 800w,/assets/img/image-inpainting/image-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/image-inpainting/image.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Image Inpainting results </div> <h2 id="abbreviations">Abbreviations</h2> <p>SN - Spectral Normalisation</p> <p>DNN- Deep Neural Networks</p> <p>CNN- Convolutional Neural Networks</p> <p>Recon - Reconstruction Loss</p> <p>GAN - Generative Adversarial Network</p> <p>SSIM - Structural Similarity Index</p> <h2 id="references">References</h2> <p>[1] D. Pathak, P. Krahenbuhl, J. Donahue, T. Darrell, and A. A. Efros. Context encoders: Feature learning by inpainting. In Proc. IEEE Conference on Computer Vision and Pattern Recognition, pages 2536–2544, 2016.</p> <p>[2] J. Yu, Z. Lin, J. Yang, X. Shen, X. Lu, and T. S. Huang. Generative image inpainting with contextual attention. In Proc. IEEE Conference on Computer Vision and Pattern Recognition, pages 5505–5514, 2018.</p> <p>[3] K. Nazeri, E. Ng, T. Joseph, F. Qureshi, and M. Ebrahimi. Edgeconnect: Generative image inpainting with adversarial edge learning. IEEE International Conference on Computer Vision Workshop, 2019.</p> <p>[4] G. Liu, F. A. Reda, K. J. Shih, T.-C. Wang, A. Tao, and B. Catanzaro. Image inpainting for irregular holes using partial convolutions. In Proc. European Conference on Computer Vision, 2018.</p> <p>[5] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolutional networks for biomedical image segmentation. In International Conference on Medical Image Computing and Computer-Assisted Intervention, pages 234–241, 2015.</p> <p>[6] Yu, Jiahui, et al. “Free-form image inpainting with gated convolution.” Proceedings of the IEEE/CVF International Conference on Computer Vision. 2019.</p> <p>[7] Miyato, Takeru, et al. “Spectral normalization for generative adversarial networks.” arXiv preprint arXiv:1802.05957 (2018).</p> <p>[8] Deepak Pathak, Philipp Krahenbuhl, Jeff Donahue, Trevor Darrell, and Alexei A Efros. Context encoders: Feature learning by inpainting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 2536–2544, 2016.</p> <p>[9] Jia-Bin Huang, Johannes Kopf, Narendra Ahuja, and Sing Bing Kang. Transformation guided image completion. In Computational Photography (ICCP), 2013 IEEE International Conference on, pages 1–9. IEEE, 2013.</p> <p>[10] Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional networks. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 933–941. JMLR. org, 2017.</p> <p>[11] Raymond A Yeh, Chen Chen, Teck Yian Lim, Alexander G Schwing, Mark Hasegawa-Johnson, and Minh N Do. Semantic image inpainting with deep generative models. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 5485–5493, 2017.</p> <p>[12] Yuhang Song, Chao Yang, Yeji Shen, Peng Wang, Qin Huang, and C-C Jay Kuo. Spg-net: Segmentation prediction and guidance network for image inpainting. arXiv preprint arXiv:1805.03356, 2018.</p> <p>[13] Vaswani, Ashish, et al. “Attention is all you need.” arXiv preprint arXiv:1706.03762 (2017).</p> <p>[14] Dosovitskiy, Alexey, et al. “An image is worth 16x16 words: Transformers for image recognition at scale.” arXiv preprint arXiv:2010.11929 (2020).</p> <p>[15] Jiang, Yifan, Shiyu Chang, and Zhangyang Wang. “Transgan: Two transformers can make one strong gan.” arXiv preprint arXiv:2102.07074 1.3 (2021).</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Naga Harshita Marupaka. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>